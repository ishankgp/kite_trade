<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Phoenix Iron Fly Dashboard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    :root { color-scheme: only light; }
    body {
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(180deg, #f8fbff 0%, #eef2ff 100%);
      color: #1e293b;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      padding: 32px 48px;
      background: linear-gradient(135deg, #6366f1 0%, #0ea5e9 100%);
      color: #fff;
      box-shadow: 0 20px 40px -28px rgba(99, 102, 241, 0.6);
    }
    header h1 {
      margin: 0 0 6px;
      font-size: 28px;
      font-weight: 700;
      letter-spacing: 0.02em;
    }
    header p {
      margin: 0;
      color: rgba(255, 255, 255, 0.88);
      font-size: 15px;
    }
    main {
      flex: 1;
      padding: 36px 32px 64px;
      display: flex;
      flex-direction: column;
      gap: 28px;
      max-width: 1400px;
      width: 100%;
      margin: 0 auto;
    }
    .card {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(226, 232, 240, 0.9);
      border-radius: 20px;
      padding: 28px;
      box-shadow: 0 15px 45px -25px rgba(15, 23, 42, 0.35);
    }
    .card h2 {
      margin: 0 0 16px;
      font-size: 20px;
      font-weight: 600;
      color: #1e293b;
    }
    .grid-two {
      display: grid;
      gap: 24px;
      grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
    }
    label {
      display: block;
      font-size: 13px;
      margin-bottom: 6px;
      color: #64748b;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    input, select, button {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(203, 213, 225, 0.9);
      background: #f8fafc;
      color: #1f2937;
      font-size: 14px;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    input:focus, select:focus, button:focus {
      outline: none;
      border-color: rgba(79, 70, 229, 0.6);
      box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.15);
    }
    button {
      cursor: pointer;
      font-weight: 600;
      background: linear-gradient(135deg, #6366f1 0%, #3b82f6 100%);
      border: none;
      color: #fff;
      box-shadow: 0 15px 35px -18px rgba(99, 102, 241, 0.6);
    }
    button:hover {
      background: linear-gradient(135deg, #4f46e5 0%, #2563eb 100%);
    }
    .status {
      font-size: 14px;
      color: #2563eb;
      margin-top: 12px;
      min-height: 20px;
    }
    .metadata-list {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 6px;
      font-size: 14px;
    }
    .metadata-list li {
      background: #f8fafc;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(226, 232, 240, 0.9);
    }
    .metrics-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }
    .metric-tile {
      padding: 16px 18px;
      border-radius: 16px;
      background: rgba(99, 102, 241, 0.08);
      border: 1px solid rgba(99, 102, 241, 0.15);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .metric-tile h4 {
      margin: 0;
      font-size: 12px;
      font-weight: 600;
      color: #4338ca;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .metric-value {
      font-size: 22px;
      font-weight: 700;
      color: #1e293b;
    }
    .metric-sub {
      font-size: 12px;
      color: #64748b;
    }
    .charts {
      display: grid;
      gap: 28px;
    }
    .chart-box {
      background: #ffffff;
      border-radius: 20px;
      padding: 20px 24px 24px;
      border: 1px solid rgba(226, 232, 240, 0.9);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }
    .chart-box h3 {
      margin: 0 0 12px;
      font-size: 18px;
      font-weight: 600;
      color: #1f2937;
    }
    footer {
      padding: 20px 32px;
      text-align: center;
      color: #475569;
      font-size: 13px;
      border-top: 1px solid rgba(203, 213, 225, 0.6);
      background: rgba(255, 255, 255, 0.78);
    }
    @media (max-width: 768px) {
      header, main, footer { padding-left: 18px; padding-right: 18px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Phoenix Iron Fly – Interactive Dashboard</h1>
    <p>Replay simulated Bank Nifty iron-fly runs with live MTM & payoff visuals.</p>
  </header>
  <main>
    <div id="root"></div>
  </main>
  <footer>
    Phoenix Strategy Toolkit • Simulation Only • © 2025
  </footer>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <script>
    const { useState, useEffect, useMemo } = React;

    const DEFAULT_REFRESH_SECONDS = 30;

    function buildQuery(params) {
      const search = new URLSearchParams();
      Object.entries(params).forEach(([key, value]) => {
        if (value) search.set(key, value);
      });
      const result = search.toString();
      return result ? `?${result}` : '';
    }

    function calculateMetrics(payload) {
      const mtmSeries = payload?.mtm_series ?? [];
      if (!mtmSeries.length) {
        return null;
      }

      let maxMtm = -Infinity;
      let minMtm = Infinity;
      let maxMtmTime = null;
      let maxDrawdown = 0;
      let maxDdTime = null;
      let peak = mtmSeries[0].mtm ?? 0;
      const drawdownSeries = [];

      mtmSeries.forEach(point => {
        const value = point.mtm ?? 0;
        if (value > maxMtm) {
          maxMtm = value;
          maxMtmTime = point.timestamp;
        }
        if (value < minMtm) {
          minMtm = value;
        }

        if (value > peak) {
          peak = value;
        }
        const drawdown = peak - value;
        drawdownSeries.push({ timestamp: point.timestamp, drawdown });
        if (drawdown > maxDrawdown) {
          maxDrawdown = drawdown;
          maxDdTime = point.timestamp;
        }
      });

      const netMtm = mtmSeries.at(-1).mtm ?? 0;

      const entry = payload.position.details;
      const entryPrices = payload.entry_prices ?? {};
      const lotSize = entry.lot_size ?? 1;
      const qty = lotSize;
      const credit = ((entryPrices.short_call ?? 0) + (entryPrices.short_put ?? 0) - (entryPrices.long_call ?? 0) - (entryPrices.long_put ?? 0)) * qty;

      const payoff = payload.payoff ?? [];
      const breakevens = [];
      for (let i = 1; i < payoff.length; i += 1) {
        const prev = payoff[i - 1];
        const current = payoff[i];
        if ((prev.payoff <= 0 && current.payoff >= 0) || (prev.payoff >= 0 && current.payoff <= 0)) {
          const slope = (current.payoff - prev.payoff) / (current.underlying - prev.underlying || 1);
          const intercept = prev.payoff - slope * prev.underlying;
          const x = slope === 0 ? prev.underlying : -intercept / slope;
          breakevens.push(Math.round(x));
        }
      }

      return {
        net_mtm: netMtm,
        max_mtm: maxMtm,
        max_mtm_time: maxMtmTime,
        min_mtm: minMtm,
        max_drawdown: -Math.abs(maxDrawdown),
        max_dd_time: maxDdTime,
        drawdown_series: drawdownSeries,
        initial_credit: credit,
        breakeven_prices: Array.from(new Set(breakevens)).sort((a, b) => a - b),
      };
    }

    function formatCurrency(value) {
      if (value === null || value === undefined || Number.isNaN(value)) {
        return '—';
      }
      const formatter = new Intl.NumberFormat('en-IN', { maximumFractionDigits: 0 });
      const sign = value >= 0 ? '' : '-';
      return `${sign}₹${formatter.format(Math.abs(value))}`;
    }

    function IronFlyDashboard() {
      const [eventLogOverride, setEventLogOverride] = useState('');
      const [stateLogOverride, setStateLogOverride] = useState('');
      const [positions, setPositions] = useState([]);
      const [selectedPositionId, setSelectedPositionId] = useState('');
      const [status, setStatus] = useState('Loading positions…');
      const [positionData, setPositionData] = useState(null);
      const [autoRefresh, setAutoRefresh] = useState(true);
      const [refreshSeconds, setRefreshSeconds] = useState(DEFAULT_REFRESH_SECONDS);

      const eventLogInfo = useMemo(() => eventLogOverride.trim(), [eventLogOverride]);
      const stateLogInfo = useMemo(() => stateLogOverride.trim(), [stateLogOverride]);
      const [metrics, setMetrics] = useState(null);

      const loadPositions = async (showSpinner = true) => {
        try {
          if (showSpinner) setStatus('Loading positions…');
          const response = await fetch(`/api/positions${buildQuery({ event_log: eventLogInfo })}`);
          if (!response.ok) throw new Error('Unable to load positions');
          const payload = await response.json();
          setPositions(payload.positions ?? []);
          if (payload.positions?.length) {
            setSelectedPositionId(prev => prev || payload.default_position_id || payload.positions.at(-1).position_id);
            setStatus(`Loaded ${payload.positions.length} positions`);
          } else {
            setSelectedPositionId('');
            setStatus('No ENTRY events found.');
          }
        } catch (error) {
          console.error(error);
          setStatus(error.message || 'Failed to load positions');
          setPositions([]);
          setSelectedPositionId('');
        }
      };

      const loadPositionData = async (manual = true) => {
        if (!selectedPositionId) {
          setStatus('Select a position to load details.');
          setPositionData(null);
          return;
        }

        try {
          setStatus(manual ? `Loading position ${selectedPositionId}…` : `Refreshing ${selectedPositionId}…`);
          const response = await fetch(`/api/position/${encodeURIComponent(selectedPositionId)}${buildQuery({ event_log: eventLogInfo, state_log: stateLogInfo })}`);
          if (!response.ok) {
            const message = await response.text();
            throw new Error(message || 'Failed to load position');
          }
          const payload = await response.json();
          setPositionData(payload);
          setStatus(`Last updated ${new Date(payload.last_updated).toLocaleString()}`);
          setMetrics(calculateMetrics(payload));
        } catch (error) {
          console.error(error);
          setStatus(error.message || 'Failed to load position');
          setPositionData(null);
          setMetrics(null);
        }
      };

      useEffect(() => {
        loadPositions(true);
      }, []);

      useEffect(() => {
        loadPositionData(false);
      }, [selectedPositionId]);

      useEffect(() => {
        if (!autoRefresh || !selectedPositionId) return undefined;
        const seconds = Math.max(5, Number.parseInt(refreshSeconds, 10) || DEFAULT_REFRESH_SECONDS);
        const interval = setInterval(() => loadPositionData(false), seconds * 1000);
        return () => clearInterval(interval);
      }, [autoRefresh, selectedPositionId, refreshSeconds, eventLogInfo, stateLogInfo]);

      useEffect(() => {
        if (!positionData) return;
        const { mtm_series: mtmSeries, payoff, position } = positionData;

        const mtmTrace = {
          x: mtmSeries.map(pt => new Date(pt.timestamp)),
          y: mtmSeries.map(pt => pt.mtm ?? null),
          mode: 'lines+markers',
          name: 'MTM (₹)',
          line: { color: '#2563eb', width: 3, shape: 'spline', smoothing: 1.2 },
          marker: { color: '#1d4ed8', size: 6 },
          connectgaps: true,
          fill: 'tozeroy',
          fillcolor: 'rgba(37, 99, 235, 0.12)',
          hovertemplate: '<b>%{x|%d %b, %I:%M %p}</b><br>MTM: %{y:,.0f}₹<extra></extra>',
        };

        const mtmLayout = {
          margin: { t: 24, r: 24, l: 70, b: 60 },
          paper_bgcolor: '#ffffff',
          plot_bgcolor: '#f8fafc',
          height: 420,
          xaxis: {
            title: 'Timestamp',
            showgrid: true,
            gridcolor: 'rgba(226, 232, 240, 0.8)',
            tickfont: { color: '#475569' },
            titlefont: { color: '#334155' },
            zeroline: false,
          },
          yaxis: {
            title: 'Mark-to-Market (₹)',
            showgrid: true,
            zeroline: true,
            zerolinecolor: 'rgba(37, 99, 235, 0.25)',
            gridcolor: 'rgba(226, 232, 240, 0.8)',
            tickfont: { color: '#475569' },
            titlefont: { color: '#334155' },
          },
          hovermode: 'x unified',
          legend: {
            orientation: 'h',
            y: 1.12,
            x: 0,
            font: { color: '#1f2937' },
          },
        };

        if (metrics?.drawdown_series) {
          const ddTrace = {
            x: metrics.drawdown_series.map(pt => new Date(pt.timestamp)),
            y: metrics.drawdown_series.map(pt => pt.drawdown),
            mode: 'lines',
            name: 'Drawdown',
            line: { color: '#f97316', width: 2, dash: 'dash' },
            yaxis: 'y2',
            hovertemplate: '%{y:.0f}₹ drawdown<extra></extra>',
          };
          mtmLayout.yaxis2 = {
            overlaying: 'y',
            side: 'right',
            showgrid: false,
            tickfont: { color: '#ea580c' },
            titlefont: { color: '#ea580c' },
            title: 'Drawdown (₹)',
          };
          Plotly.react('mtm-chart', [mtmTrace, ddTrace], mtmLayout, { displayModeBar: false });
        } else {
          Plotly.react('mtm-chart', [mtmTrace], mtmLayout, { displayModeBar: false });
        }

        const payoffTrace = {
          x: payoff.map(pt => pt.underlying),
          y: payoff.map(pt => pt.payoff),
          mode: 'lines',
          name: 'Payoff @ Expiry',
          line: { color: '#10b981', width: 3, shape: 'spline', smoothing: 1.1 },
          fill: 'tozeroy',
          fillcolor: 'rgba(16, 185, 129, 0.12)',
          hovertemplate: 'Underlying: %{x}<br>Payoff: %{y:,.0f}₹<extra></extra>',
        };

        const payoffBreakeven = (metrics?.breakeven_prices ?? []).map(price => ({
          x: [price, price],
          y: [Math.min(...payoff.map(pt => pt.payoff)), Math.max(...payoff.map(pt => pt.payoff))],
          mode: 'lines',
          line: { dash: 'dash', color: 'rgba(148, 163, 184, 0.4)' },
          name: `Breakeven ${price}`,
          hoverinfo: 'skip',
          showlegend: false,
        }));

        const payoffLayout = {
          margin: { t: 24, r: 24, l: 70, b: 60 },
          paper_bgcolor: '#ffffff',
          plot_bgcolor: '#f8fafc',
          height: 420,
          xaxis: {
            title: 'Underlying Price',
            showgrid: true,
            gridcolor: 'rgba(226, 232, 240, 0.8)',
            tickfont: { color: '#475569' },
            titlefont: { color: '#334155' },
          },
          yaxis: {
            title: 'Payoff at Expiry (₹)',
            zeroline: true,
            zerolinecolor: 'rgba(16, 185, 129, 0.25)',
            showgrid: true,
            gridcolor: 'rgba(226, 232, 240, 0.8)',
            tickfont: { color: '#475569' },
            titlefont: { color: '#334155' },
          },
          hovermode: 'x unified',
          shapes: (metrics?.breakeven_prices ?? []).map(price => ({
            type: 'line',
            x0: price,
            x1: price,
            y0: Math.min(...payoff.map(pt => pt.payoff)),
            y1: Math.max(...payoff.map(pt => pt.payoff)),
            line: { dash: 'dash', color: 'rgba(148, 163, 184, 0.25)' },
          })),
        };

        Plotly.react('payoff-chart', [payoffTrace, ...payoffBreakeven], payoffLayout, { displayModeBar: false });

        if (!document.getElementById('position-details')) return;
      }, [positionData]);

      const renderPositionOptions = () => positions.map(item => (
        React.createElement('option', { key: item.position_id, value: item.position_id }, `${item.position_id} – ${item.timestamp}`)
      ));

      const toggleAutoRefresh = () => setAutoRefresh(prev => !prev);

      return React.createElement('div', { className: 'dashboard' },
          React.createElement('div', { className: 'card' },
          React.createElement('h2', null, 'Data Feeds'),
            React.createElement('div', { className: 'grid-two' },
              React.createElement('div', null,
              React.createElement('label', { htmlFor: 'eventLogInput' }, 'Event Log Path (optional)'),
                React.createElement('input', {
                id: 'eventLogInput',
                value: eventLogOverride,
                onChange: e => setEventLogOverride(e.target.value),
                  placeholder: '../trade_logs/event_log_YYYY-MM.csv',
                })
              ),
              React.createElement('div', null,
              React.createElement('label', { htmlFor: 'stateLogInput' }, 'State Log Path (optional)'),
                React.createElement('input', {
                id: 'stateLogInput',
                value: stateLogOverride,
                onChange: e => setStateLogOverride(e.target.value),
                  placeholder: '../trade_logs/state_log_YYYY-MM-DD.csv',
                })
              ),
              React.createElement('div', null,
              React.createElement('label', { htmlFor: 'positionSelect' }, 'Position'),
              React.createElement('select', {
                id: 'positionSelect',
                value: selectedPositionId,
                onChange: e => setSelectedPositionId(e.target.value),
              },
                renderPositionOptions()
              )
            ),
            React.createElement('div', null,
              React.createElement('label', { htmlFor: 'refreshSeconds' }, 'Refresh (seconds)'),
                React.createElement('input', {
                id: 'refreshSeconds',
                type: 'number',
                min: 5,
                value: refreshSeconds,
                onChange: e => setRefreshSeconds(e.target.value),
                })
              ),
              React.createElement('div', null,
              React.createElement('label', { htmlFor: 'autoRefreshToggle' }, 'Auto Refresh'),
              React.createElement('button', {
                id: 'autoRefreshToggle',
                onClick: toggleAutoRefresh,
              }, autoRefresh ? 'Disable Auto Refresh' : 'Enable Auto Refresh')
            ),
            React.createElement('div', null,
              React.createElement('label', { htmlFor: 'refreshPositions' }, 'Actions'),
              React.createElement('div', { style: { display: 'flex', gap: '8px' } },
                React.createElement('button', { id: 'refreshPositions', onClick: () => loadPositions(true) }, 'Reload Positions'),
                React.createElement('button', { onClick: () => loadPositionData(true) }, 'Refresh Charts')
              )
            )
          ),
          React.createElement('div', { className: 'status' }, status)
        ),

        positionData ? React.createElement('div', { className: 'grid-two' },
          React.createElement('div', { className: 'card', id: 'position-details' },
              React.createElement('h2', null, 'Position Snapshot'),
              React.createElement('ul', { className: 'metadata-list' },
              React.createElement('li', null, `Position ID: ${positionData.position.position_id}`),
              React.createElement('li', null, `Entry Time: ${positionData.position.timestamp}`),
              React.createElement('li', null, `Expiry: ${positionData.position.details.expiry}`),
              React.createElement('li', null, `ATM Strike: ${positionData.position.details.atm_strike}`),
              React.createElement('li', null, `Wing Distance: ${positionData.position.details.wing_distance} pts`),
              React.createElement('li', null, `Lot Size: ${positionData.position.details.lot_size}`),
              React.createElement('li', null, `Event Log: ${positionData.event_log_path}`),
              React.createElement('li', null, `State Log: ${positionData.state_log_path}`),
              )
            ),
            React.createElement('div', { className: 'card charts' },
            metrics ? React.createElement('div', { className: 'metrics-grid' },
              React.createElement('div', { className: 'metric-tile' },
                React.createElement('h4', null, 'Net MTM'),
                React.createElement('div', { className: 'metric-value' }, `${formatCurrency(metrics.net_mtm)}`),
                React.createElement('div', { className: 'metric-sub' }, 'Current unrealised P&L')
              ),
              React.createElement('div', { className: 'metric-tile' },
                React.createElement('h4', null, 'Max MTM'),
                React.createElement('div', { className: 'metric-value' }, `${formatCurrency(metrics.max_mtm)}`),
                metrics.max_mtm_time ? React.createElement('div', { className: 'metric-sub' }, `Peak at ${new Date(metrics.max_mtm_time).toLocaleTimeString()}`) : React.createElement('div', { className: 'metric-sub' }, 'Peak mark-to-market'),
              ),
              React.createElement('div', { className: 'metric-tile' },
                React.createElement('h4', null, 'Max Drawdown'),
                React.createElement('div', { className: 'metric-value' }, `${formatCurrency(metrics.max_drawdown)}`),
                React.createElement('div', { className: 'metric-sub' }, metrics.max_dd_time ? `Occurred ${new Date(metrics.max_dd_time).toLocaleTimeString()}` : '—')
              ),
              React.createElement('div', { className: 'metric-tile' },
                React.createElement('h4', null, 'Entry Credit'),
                React.createElement('div', { className: 'metric-value' }, `${formatCurrency(metrics.initial_credit)}`),
                React.createElement('div', { className: 'metric-sub' }, 'Sum of short premiums minus longs')
              ),
              React.createElement('div', { className: 'metric-tile' },
                React.createElement('h4', null, 'Breakevens'),
                React.createElement('div', { className: 'metric-value' }, metrics.breakeven_prices?.length ? metrics.breakeven_prices.join(' / ') : '—'),
                React.createElement('div', { className: 'metric-sub' }, 'Expiry breakeven strikes')
              )
            ) : null,
              React.createElement('div', { className: 'chart-box' },
                React.createElement('h3', null, 'Mark-to-Market Timeline'),
                React.createElement('div', { id: 'mtm-chart', style: { height: '320px' } })
              ),
              React.createElement('div', { className: 'chart-box' },
                React.createElement('h3', null, 'Expiry Payoff Curve'),
                React.createElement('div', { id: 'payoff-chart', style: { height: '320px' } })
              )
            )
        ) : React.createElement('div', { className: 'card' },
          React.createElement('p', null, 'No data to display. Use Reload Positions or Refresh Charts once a position is available.')
        )
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(IronFlyDashboard));
  </script>
</body>
</html>
